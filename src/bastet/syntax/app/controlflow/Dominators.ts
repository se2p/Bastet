/*
 *   BASTET Program Analysis and Verification Framework
 *
 *   Copyright 2019 by University of Passau (uni-passau.de)
 *
 *   Maintained by Andreas Stahlbauer (firstname@lastname.net),
 *   see the file CONTRIBUTORS.md for the list of contributors.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 *
 */

import {LocationId} from "./ControlLocation";
import {TransitionRelation, TransitionTo} from "./TransitionRelation";
import {Preconditions} from "../../../utils/Preconditions";
import {getTheOnlyElement} from "../../../utils/Collections";
import {Map as ImmMap, Set as ImmSet} from "immutable"
import {ImplementMeException} from "../../../core/exceptions/ImplementMeException";

export class NodeInfo {

    /**
     * "The vertex which is the parent of vertex w in the spanning tree generated by the search."
     */
    private _parent: LocationId;

    /**
     * The set of vertices v such that (v, w) is an edge of the graph.
     */
    private _pred: Set<LocationId>;

    /**
     * A number defined as follows:
     *   - semi = O: Before Vertex w is numbered.
     *   - semi = n: After numbering but before semi-dominator computation (n = number of the vertice).
     *   - semi = s: Number s of the semi-dominator of this vertice.
     */
    private _semi: number;

    private _dfs: number;

    /**
     * Set of vertices whose semi-dominator this vertice is.
     */
    private _bucket: Set<LocationId>;

    private _ancestor: LocationId;
    private _label: LocationId;

    constructor() {
        this._pred = new Set<LocationId>();
        this._bucket = new Set<LocationId>();
        this._semi = 0;
        this._dfs = -1;
    }

    get parent(): number {
        return this._parent;
    }

    get dfs(): number {
        return this._dfs;
    }

    set dfs(value: number) {
        this._dfs = value;
    }

    set parent(value: number) {
        this._parent = value;
    }

    get pred(): Set<LocationId> {
        return this._pred;
    }

    set pred(value: Set<LocationId>) {
        this._pred = value;
    }

    get bucket(): Set<LocationId> {
        return this._bucket;
    }

    set bucket(value: Set<LocationId>) {
        this._bucket = value;
    }

    get semi(): number {
        return this._semi;
    }

    set semi(value: number) {
        this._semi = value;
    }

    get ancestor(): number {
        return this._ancestor;
    }

    set ancestor(value: number) {
        this._ancestor = value;
    }

    get label(): number {
        return this._label;
    }

    set label(value: number) {
        this._label = value;
    }
}

export enum DominanceMode {
    FORWARDS,
    BACKWARDS
}

/**
 * Lengauer and Tarjan,
 * "A Fast Algorithm for Finding Dominators in a Flow Graph", 1977
 */
export class ControlDominance {

    private readonly _mode: DominanceMode;

    private readonly _tr: TransitionRelation;
    private readonly _vertex: Array<LocationId>;
    private readonly _map: Map<LocationId, NodeInfo>;
    private readonly _dominatedBy: Map<LocationId, LocationId>;

    private readonly _entry: LocationId;

    private _dfs_number: number;
    private readonly _nodes: ImmSet<LocationId>;

    constructor(tr: TransitionRelation, mode: DominanceMode) {
        this._dfs_number = 0;
        this._tr = Preconditions.checkNotUndefined(tr);
        this._entry = getTheOnlyElement(tr.entryLocationSet);
        this._mode = mode;
        this._nodes = tr.locationSet;
        this._map = new Map<LocationId, NodeInfo>();
        this._dominatedBy = new Map<LocationId, LocationId>();
        this._vertex = new Array<LocationId>();
        for (let i = 0; i < tr.locationSet.size + 1; i++) {
            this._vertex.push(-1);
        }
    }

    private getNodeWithDfsNumber(dfsNum: number): LocationId {
        return this._vertex[dfsNum];
    }

    public computeDominators(): this {
        // DFS to number the vertices
        this.step1();
        for (let i = this._dfs_number; i > 1; i--) {
            const w: LocationId = this.getNodeWithDfsNumber(i);
            this.step2(w);
            this.step3(w);
        }
        this.step4();

        return this;
    }

    /**
     * "Carry out a depth-first search of the problem graph.
     * Number the vertices from 1 to n as they are reached during the search [DFS numbering].
     * Initialize the variables used in succeeding steps."
     */
    private step1(): void {
        this._dfs_number = 0;
        for (const v of this._nodes) {
            const infov: NodeInfo = new NodeInfo();
            this._map.set(v, infov);
        }

        if (this._mode == DominanceMode.FORWARDS) {
            this.dfs(this._entry);
        } else {
            throw new ImplementMeException();
        }
    }

    private getNodeInfo(nodeId: LocationId): NodeInfo {
        return this._map.get(nodeId);
    }

    /**
     * Compute the semi-dominators of all vertices by applying Theorem 4.
     * Carry out the computation vertex-by-vertex in decreasing order by number.
     */
    private step2(pNodeW: LocationId): void {
        const infow: NodeInfo = this.getNodeInfo(pNodeW);

        for (const v of infow.pred) {
            const u: LocationId = this.eval(v);
            const infou: NodeInfo = this.getNodeInfo(u);

            if (infou.semi < infow.semi) {
                infow.semi = infou.semi;
            }

            const t: LocationId = this.getNodeWithDfsNumber(infow.semi);
            const infot: NodeInfo = this.getNodeInfo(t);
            infot.bucket.add(pNodeW);

            this.link(infow.parent, pNodeW);
        }
    }

    /**
     * Implicitly define the immediate dominator of each vertex by applying Corollary 1.
     */
    private step3(pNodeW: LocationId): void {
        const infow: NodeInfo = this.getNodeInfo(pNodeW);
        const infopw: NodeInfo = this.getNodeInfo(infow.parent);

        for (const v of infopw.bucket) {
            const infov = this.getNodeInfo(v);
            const u: LocationId = this.eval(v);
            const infou: NodeInfo = this.getNodeInfo(u);

            if (infou.semi < infov.semi) {
                this._dominatedBy.set(v, u);
            } else {
                this._dominatedBy.set(v, infow.parent);
            }
        }

        infopw.bucket = new Set();
    }

    /**
     * Explicitly define the immediate dominator of each vertex,
     * carrying out the computation vertex-by-vertex in increasing order by number.
     */
    private step4(): void {
        for (let i = 2; i < this._dfs_number; i++) {
            const w: LocationId = this.getNodeWithDfsNumber(i);
            const infow: NodeInfo = this.getNodeInfo(w);
            const d: LocationId = this._dominatedBy.get(w);

            if (!(d == this.getNodeWithDfsNumber(infow.semi))) {
                const dd: LocationId = this._dominatedBy.get(d);
                this._dominatedBy.set(d, dd);
            }
        }

        if (this._mode == DominanceMode.FORWARDS) {
            this._dominatedBy.set(this._entry, null);
        } else {
            throw new ImplementMeException();
        }
    }

    public getDfsNumber(pNode: LocationId): number {
        return this.getNodeInfo(pNode).dfs;
    }

    private dfs(pNode: LocationId): void {
        this._dfs_number = this._dfs_number + 1;

        const infov: NodeInfo = this._map.get(pNode);
        infov.semi = this._dfs_number;
        infov.dfs = this._dfs_number;
        infov.label = pNode;
        infov.ancestor = null;

        this._vertex[this._dfs_number] = pNode;

        let trans: Array<TransitionTo> = this._tr.transitionsFrom(pNode);
        if (this._mode == DominanceMode.FORWARDS) {
            trans = this._tr.transitionsFrom(pNode);
        } else {
            throw new ImplementMeException();
        }

        /**
         * TODO: Add code there to support Super-CFAs?
         */

        for (let i = 0; i < trans.length; i++) {
            const w: LocationId = trans[i].target;

            const infow: NodeInfo = this._map.get(w);
            if (infow.semi == 0) {
                infow.parent = pNode;
                this.dfs(w);
            }

            infow.pred.add(pNode);
        }
    }

    private compress(pNode: LocationId): void {
        const infov = this.getNodeInfo(pNode);
        const av: LocationId = infov.ancestor;
        const infoav: NodeInfo = this._map.get(av);

        if (infoav.ancestor != null) {
            this.compress(av);
            const infovl: NodeInfo = this.getNodeInfo(infov.label);
            const infoavl: NodeInfo = this.getNodeInfo(infoav.label);

            if (infoavl.semi < infovl.semi) {
                infov.label = infoav.label;
            }
            infov.ancestor = infoav.ancestor;
        }
    }

    private eval(pNode: LocationId): LocationId {
        const infov: NodeInfo = this.getNodeInfo(pNode);

        if (infov.ancestor == null) {
            return pNode;
        } else {
            this.compress(pNode);
            return infov.label;
        }
    }

    private link(pNodeV: LocationId, pNodeW: LocationId): void {
        const infow: NodeInfo = this.getNodeInfo(pNodeW);
        infow.ancestor = pNodeV;
    }


    public getDominatorNodes(): ImmSet<LocationId> {
        return ImmSet(this._dominatedBy.values());
    }

    public getDominatedBy(pNode: LocationId): LocationId|null {
        return this._dominatedBy.get(pNode);
    }

    public isDominatedBy(pNode: LocationId, pIsDominatedBy: LocationId): boolean {
        if (pNode == pIsDominatedBy) {
            // A node is always dominated by itself!
            return true;
        }

        let v: LocationId = this._dominatedBy.get(pNode);
        while (v != null) {
            if (v == pIsDominatedBy) {
                return true;
            }
            v = this._dominatedBy.get(v);
        }

        return false;
    }

}
